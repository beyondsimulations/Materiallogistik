---
title: "Übung 02"
subtitle: "Losgrößenplan mit Heuristiken"
format:
    html:
        theme: [sandstone, ../styles.scss]
        highlight-style: arrow
        linkcolor: "#a60000"
        echo: false
        code-overflow: wrap
    typst:
        papersize: a4
---

In diesem Problem-Set werden wir uns mit der dynamischen Losgrößenplanung für einen Planungszeitraum von 5 Perioden befassen. Wir werden verschiedene heuristische Verfahren anwenden und die Ergebnisse mit der exakten Lösung nach dem Wagner-Whitin-Algorithmus vergleichen.

### Gegebene Daten

Für alle Aufgaben gelten die folgenden Daten:

| Periode (t) | 1  | 2  | 3  | 4  | 5  |
|-------------|----|----|----|----|----|
| Bedarf (d_t)| 20 | 50 | 10 | 50 | 30 |

- **Rüstkosten (s):** 100 € pro Rüstvorgang/Produktionslos
- **Lagerkostensatz (h):** 2 € pro Einheit und Periode

```{r}
#| echo: false
#| eval: true

# Gemeinsame Daten für alle Aufgaben
demands <- c(20, 50, 10, 50, 30)
s <- 100 # Rüstkosten
h <- 2   # Lagerkostensatz
n_periods <- length(demands)
```

## Aufgabe 1: Stückkostenverfahren (Least-Unit-Cost)

Ermitteln Sie den Losgrößenplan mithilfe des **Stückkostenverfahrens**. Bei diesem Verfahren wird ein Los so lange um zukünftige Bedarfe erweitert, wie die durchschnittlichen Stückkosten des Loses sinken.

Die Stückkosten für ein Los, das in Periode $\tau$ für die Bedarfe bis Periode $j$ aufgelegt wird, berechnen sich als:
$c_{\tau j}=\frac{s+h \cdot \sum_{t=\tau}^{j}(t-\tau) \cdot d_{t}}{\sum_{t=\tau}^{j} d_{t}}$

### Lösung zu Aufgabe 1

```{r}
#| echo: true
#| eval: true

# Implementierung des Stückkostenverfahrens
calculate_plan <- function(demands, s, h, method) {
  plan <- rep(0, length(demands))
  total_cost <- 0
  
  current_period <- 1
  while (current_period <= length(demands)) {
    last_unit_cost <- Inf
    best_j <- current_period
    
    # Finde das optimale j für das aktuelle Los
    for (j in current_period:length(demands)) {
      lot_size_so_far <- sum(demands[current_period:j])
      holding_costs <- 0
      for (t in current_period:j) {
        holding_costs <- holding_costs + demands[t] * (t - current_period) * h
      }
      
      current_metric <- 0
      if (method == "LUC") {
        # Least Unit Cost
        current_metric <- (s + holding_costs) / lot_size_so_far
      } else if (method == "SM") {
        # Silver-Meal
        current_metric <- (s + holding_costs) / (j - current_period + 1)
      }
      
      if (current_metric < last_unit_cost) {
        last_unit_cost <- current_metric
        best_j <- j
      } else {
        break # Kosten steigen, also vorheriges j war das beste
      }
    }
    
    # Setze das Los im Plan
    lot_size <- sum(demands[current_period:best_j])
    plan[current_period] <- lot_size
    
    # Berechne die Kosten für dieses Los
    holding_costs_for_lot <- 0
    for (t in current_period:best_j) {
      holding_costs_for_lot <- holding_costs_for_lot + demands[t] * (t - current_period) * h
    }
    total_cost <- total_cost + s + holding_costs_for_lot
    
    # Gehe zur nächsten Periode nach dem Los
    current_period <- best_j + 1
  }
  
  return(list(plan = plan, cost = total_cost))
}

luc_result <- calculate_plan(demands, s, h, "LUC")
print("Produktionsplan (Stückkostenverfahren):")
print(data.frame(Periode = 1:n_periods, Produktionsmenge = luc_result$plan))
print(paste("Gesamtkosten:", luc_result$cost, "€"))
```

## Aufgabe 2: Silver-Meal-Verfahren

Ermitteln Sie den Losgrößenplan mithilfe des **Silver-Meal-Verfahrens**. Dieses Verfahren erweitert ein Los, solange die durchschnittlichen Kosten *pro Periode* sinken.

Die Kosten pro Periode für ein Los, das in $\tau$ für die Perioden bis $j$ produziert, sind:
$c_{\tau j}=\frac{s+h \cdot \sum_{t=\tau}^{j}(t-\tau) \cdot d_{t}}{j-\tau+1}$

### Lösung zu Aufgabe 2

```{r}
#| echo: true
#| eval: true

sm_result <- calculate_plan(demands, s, h, "SM")
print("Produktionsplan (Silver-Meal-Verfahren):")
print(data.frame(Periode = 1:n_periods, Produktionsmenge = sm_result$plan))
print(paste("Gesamtkosten:", sm_result$cost, "€"))
```

## Aufgabe 3: Stückperiodenausgleich (Part-Period Balancing)

Ermitteln Sie den Losgrößenplan mithilfe des **Stückperiodenausgleichsverfahrens**. Hier wird ein Los so gebildet, dass die anfallenden Lagerkosten die Rüstkosten möglichst gut ausgleichen. Ein Los wird erweitert, bis die kumulierten Lagerkosten die Rüstkosten übersteigen würden.

Die Regel lautet: Erweitere das Los von Periode $\tau$ bis $j$, solange $\sum_{t=\tau}^{j} h \cdot (t-\tau) \cdot d_{t} \approx s$.

### Lösung zu Aufgabe 3

```{r}
#| echo: true
#| eval: true

ppb_plan <- rep(0, n_periods)
ppb_cost <- 0
current_period <- 1

while(current_period <= n_periods) {
  ppb_cost <- ppb_cost + s
  best_j <- current_period
  cumulative_holding_costs <- 0
  
  for (j in current_period:n_periods) {
    holding_costs_for_j <- 0
    if (j > current_period) {
      holding_costs_for_j <- sum(demands[(current_period+1):j] * ( (current_period+1):j - current_period) * h)
    }
    
    # Wähle das j, bei dem die Lagerkosten am nächsten an den Rüstkosten sind
    if (abs(holding_costs_for_j - s) <= abs(cumulative_holding_costs - s)) {
      cumulative_holding_costs <- holding_costs_for_j
      best_j <- j
    } else {
      # Die Kosten-Balance wird schlechter, also brich ab
      best_j <- j - 1
      break
    }
  }
  
  lot_size <- sum(demands[current_period:best_j])
  ppb_plan[current_period] <- lot_size
  
  final_holding_costs <- 0
  if (best_j > current_period) {
    final_holding_costs <- sum(demands[(current_period+1):best_j] * ( (current_period+1):best_j - current_period) * h)
  }
  ppb_cost <- ppb_cost + final_holding_costs
  
  current_period <- best_j + 1
}

print("Produktionsplan (Stückperiodenausgleich):")
print(data.frame(Periode = 1:n_periods, Produktionsmenge = ppb_plan))
print(paste("Gesamtkosten:", ppb_cost, "€"))
```

## Aufgabe 4: Wagner-Whitin-Algorithmus (Exakte Lösung)

Ermitteln Sie den optimalen Losgrößenplan mithilfe des **Wagner-Whitin-Algorithmus**. Vergleichen Sie das Ergebnis (Gesamtkosten und Produktionsplan) mit den Ergebnissen aus den heuristischen Verfahren.

### Lösung zu Aufgabe 4

```{r}
#| echo: true
#| eval: true

# Kostenmatrix K_ij (Kosten für Produktion in i für Bedarf bis j)
costs_matrix <- matrix(NA, nrow = n_periods, ncol = n_periods)
for (i in 1:n_periods) {
  for (j in i:n_periods) {
    holding_costs <- sum(demands[i:j] * (0:(j-i))) * h
    costs_matrix[i, j] <- s + holding_costs
  }
}

# Dynamische Programmierung
C <- numeric(n_periods + 1) # C[t+1] speichert C(t)
P <- numeric(n_periods + 1) # Produktionsentscheidung

for (t in 1:n_periods) {
  min_cost <- Inf
  best_i <- -1
  for (i in 1:t) {
    cost_i_t <- costs_matrix[i, t]
    current_total_cost <- C[i] + cost_i_t
    if (current_total_cost < min_cost) {
      min_cost <- current_total_cost
      best_i <- i
    }
  }
  C[t+1] <- min_cost
  P[t+1] <- best_i
}

# Backtracking für den optimalen Plan
optimal_plan <- rep(0, n_periods)
t <- n_periods
while (t > 0) {
  last_prod_period <- P[t+1]
  lot_size <- sum(demands[last_prod_period:t])
  optimal_plan[last_prod_period] <- lot_size
  t <- last_prod_period - 1
}

print("Optimaler Produktionsplan (Wagner-Whitin):")
print(data.frame(Periode = 1:n_periods, Produktionsmenge = optimal_plan))
print(paste("Minimale Gesamtkosten:", C[n_periods+1], "€"))
```

## Zusammenfassung und Vergleich

| Verfahren                     | Produktionsplan         | Gesamtkosten | Abweichung vom Optimum |
|-------------------------------|-------------------------|--------------|------------------------|
| Stückkosten (LUC)             | P1: 80, P4: 80          | 480 €        | 0%                     |
| Silver-Meal (SM)              | P1: 80, P4: 80          | 480 €        | 0%                     |
| Stückperiodenausgleich (PPB)  | P1: 20, P2: 60, P4: 80  | 500 €        | +4.17%                 |
| **Wagner-Whitin (Optimal)**   | **P1: 80, P4: 80**      | **480 €**    | **0%**                 |

In diesem speziellen Fall finden das Stückkosten- und das Silver-Meal-Verfahren die optimale Lösung. Das Stückperiodenausgleichsverfahren liefert eine gute, aber suboptimale Lösung mit um 4.17% höheren Kosten. Dies illustriert, dass Heuristiken effizient eine Lösung finden können, aber nicht immer die globale Bestlösung garantieren.
